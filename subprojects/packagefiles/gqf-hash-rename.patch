diff --git a/include/hashutil.cuh b/include/hashutil.cuh
index 4606369..c16954d 100644
--- a/include/hashutil.cuh
+++ b/include/hashutil.cuh
@@ -14,11 +14,11 @@
 #include <stdlib.h>
 #include <stdint.h>

-__host__ __device__ uint64_t MurmurHash64B ( const void * key, int len, unsigned int seed );
-__host__ __device__ uint64_t MurmurHash64A ( const void * key, int len, unsigned int seed );
+__host__ __device__ uint64_t aMurmurHash64B ( const void * key, int len, unsigned int seed );
+__host__ __device__ uint64_t aMurmurHash64A ( const void * key, int len, unsigned int seed );

-__host__ __device__ uint64_t hash_64(uint64_t key, uint64_t mask);
-__host__ __device__ uint64_t hash_64i(uint64_t key, uint64_t mask);
+__host__ __device__ uint64_t ahash_64(uint64_t key, uint64_t mask);
+__host__ __device__ uint64_t ahash_64i(uint64_t key, uint64_t mask);

 #endif  // #ifndef _HASHUTIL_H_

diff --git a/src/gqf.cu b/src/gqf.cu
index 36c9098..a36bf06 100644
--- a/src/gqf.cu
+++ b/src/gqf.cu
@@ -2405,9 +2405,9 @@ __host__ __device__ qf_returns qf_insert_not_exists(QF *qf, uint64_t key, uint64

 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
 		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-			key = MurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
+			key = aMurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
 		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
 	}

 	uint64_t hash = (key << qf->metadata->value_bits) | (value & BITMASK(qf->metadata->value_bits));
@@ -2478,9 +2478,9 @@ __host__ __device__ int qf_insert(QF *qf, uint64_t key, uint64_t value, uint64_t

 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
 		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-			key = MurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
+			key = aMurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
 		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
 	}

 	uint64_t hash = (key << qf->metadata->value_bits) | (value & BITMASK(qf->metadata->value_bits));
@@ -2623,10 +2623,10 @@ __global__ void hash_all(QF* qf, uint64_t* vals, uint64_t* hashes, uint64_t nval

   if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
 		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-			key = MurmurHash64A(((void *)&key), sizeof(key),
+			key = aMurmurHash64A(((void *)&key), sizeof(key),
 													qf->metadata->seed) & (qf->metadata->range - 1);
 		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
 	}

 	//uint64_t hash = (key << qf->metadata->value_bits) | (value & BITMASK(qf->metadata->value_bits));
@@ -2916,9 +2916,9 @@ __device__ qf_returns point_insert_not_exists(QF* qf, uint64_t key, uint8_t valu

 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
   		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-  			key = MurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
+  			key = aMurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
   		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-  			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+  			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
   	}

 	uint64_t hash = key % qf->metadata->range;
@@ -2972,9 +2972,9 @@ __device__ qf_returns point_insert(QF* qf, uint64_t key, uint8_t value, uint8_t

 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
   		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-  			key = MurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
+  			key = aMurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
   		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-  			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+  			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
   	}

 	uint64_t hash = key % qf->metadata->range;
@@ -3028,9 +3028,9 @@ __device__ uint64_t point_query(QF* qf, uint64_t key, uint8_t value, uint8_t& re

 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
   		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-  			key = MurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
+  			key = aMurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
   		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-  			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+  			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
   	}

 	uint64_t hash = key % qf->metadata->range;
@@ -3058,9 +3058,9 @@ __device__ uint64_t point_query_concurrent(QF* qf, uint64_t key, uint8_t value,

 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
   		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-  			key = MurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
+  			key = aMurmurHash64A(((void *)&key), sizeof(key), qf->metadata->seed) % qf->metadata->range;
   		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-  			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+  			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
   	}

 	uint64_t hash = key % qf->metadata->range;
@@ -3448,10 +3448,10 @@ __host__ __device__ int qf_remove(QF *qf, uint64_t key, uint64_t value, uint64_t

 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
 		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-			key = MurmurHash64A(((void *)&key), sizeof(key),
+			key = aMurmurHash64A(((void *)&key), sizeof(key),
 													qf->metadata->seed) % qf->metadata->range;
 		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
 	}
 	uint64_t hash = (key << qf->metadata->value_bits) | (value &
 																											 BITMASK(qf->metadata->value_bits));
@@ -3466,10 +3466,10 @@ __host__ __device__ int qf_delete_key_value(QF *qf, uint64_t key, uint64_t value

 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
 		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-			key = MurmurHash64A(((void *)&key), sizeof(key),
+			key = aMurmurHash64A(((void *)&key), sizeof(key),
 													qf->metadata->seed) % qf->metadata->range;
 		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
 	}
 	uint64_t hash = (key << qf->metadata->value_bits) | (value &
 																											 BITMASK(qf->metadata->value_bits));
@@ -3483,10 +3483,10 @@ __host__ __device__ uint64_t qf_count_key_value(const QF *qf, uint64_t key, uint

 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
 		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-			key = MurmurHash64A(((void *)&key), sizeof(key),
+			key = aMurmurHash64A(((void *)&key), sizeof(key),
 													qf->metadata->seed) % qf->metadata->range;
 		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
 	}

 	uint64_t hash = (key << qf->metadata->value_bits) | (value &
@@ -3521,10 +3521,10 @@ __host__ __device__ uint64_t qf_query(const QF *qf, uint64_t key, uint64_t *valu
 {
 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
 		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-			key = MurmurHash64A(((void *)&key), sizeof(key),
+			key = aMurmurHash64A(((void *)&key), sizeof(key),
 													qf->metadata->seed) % qf->metadata->range;
 		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
 	}
 	uint64_t hash = key;
 	uint64_t hash_remainder   = hash & BITMASK(qf->metadata->key_remainder_bits);
@@ -3561,10 +3561,10 @@ __host__ __device__ int64_t qf_get_unique_index(const QF *qf, uint64_t key, uint
 {
 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
 		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-			key = MurmurHash64A(((void *)&key), sizeof(key),
+			key = aMurmurHash64A(((void *)&key), sizeof(key),
 													qf->metadata->seed) % qf->metadata->range;
 		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
 	}
 	uint64_t hash = (key << qf->metadata->value_bits) | (value &
 																											 BITMASK(qf->metadata->value_bits));
@@ -3709,10 +3709,10 @@ int64_t qf_iterator_from_key_value(const QF *qf, QFi *qfi, uint64_t key,

 	if (GET_KEY_HASH(flags) != QF_KEY_IS_HASH) {
 		if (qf->metadata->hash_mode == QF_HASH_DEFAULT)
-			key = MurmurHash64A(((void *)&key), sizeof(key),
+			key = aMurmurHash64A(((void *)&key), sizeof(key),
 													qf->metadata->seed) % qf->metadata->range;
 		else if (qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-			key = hash_64(key, BITMASK(qf->metadata->key_bits));
+			key = ahash_64(key, BITMASK(qf->metadata->key_bits));
 	}
 	uint64_t hash = (key << qf->metadata->value_bits) | (value &
 																											 BITMASK(qf->metadata->value_bits));
@@ -3798,7 +3798,7 @@ int qfi_get_key(const QFi *qfi, uint64_t *key, uint64_t *value, uint64_t
 			*key = 0; *value = 0; *count = 0;
 			return QF_INVALID;
 		} else if (qfi->qf->metadata->hash_mode == QF_HASH_INVERTIBLE)
-			*key = hash_64i(*key, BITMASK(qfi->qf->metadata->key_bits));
+			*key = ahash_64i(*key, BITMASK(qfi->qf->metadata->key_bits));
 	}

 	return ret;
diff --git a/src/gqf_verify.cu b/src/gqf_verify.cu
index 85da5be..e2f8729 100644
--- a/src/gqf_verify.cu
+++ b/src/gqf_verify.cu
@@ -217,9 +217,9 @@ int main(int argc, char** argv) {


 		for (int i = 0; i < kmers.size(); i++){
-			hashes.push_back(MurmurHash64A(kmers[i].c_str(), KMER_SIZE, 1));
+			hashes.push_back(aMurmurHash64A(kmers[i].c_str(), KMER_SIZE, 1));
 		}
-		//uint64_t MurmurHash64A ( const void * key, int len, unsigned int seed )
+		//uint64_t aMurmurHash64A ( const void * key, int len, unsigned int seed )

 		for (int i=0; i < 10; i++){
 			printf("%d: %llu\n", i, hashes[i]);
diff --git a/src/hashutil.cu b/src/hashutil.cu
index fef0def..88cea3d 100644
--- a/src/hashutil.cu
+++ b/src/hashutil.cu
@@ -20,7 +20,7 @@

 // 64-bit hash for 64-bit platforms

-__host__ __device__ uint64_t MurmurHash64A ( const void * key, int len, unsigned int seed )
+__host__ __device__ uint64_t aMurmurHash64A ( const void * key, int len, unsigned int seed )
 {
 	const uint64_t m = 0xc6a4a7935bd1e995;
 	const int r = 47;
@@ -66,7 +66,7 @@ __host__ __device__ uint64_t MurmurHash64A ( const void * key, int len, unsigned

 // 64-bit hash for 32-bit platforms

-__host__ __device__ uint64_t MurmurHash64B ( const void * key, int len, unsigned int seed )
+__host__ __device__ uint64_t aMurmurHash64B ( const void * key, int len, unsigned int seed )
 {
 	const unsigned int m = 0x5bd1e995;
 	const int r = 24;
@@ -129,7 +129,7 @@ __host__ __device__ uint64_t MurmurHash64B ( const void * key, int len, unsigned
 // Thomas Wang's integer hash functions. See
 // <https://gist.github.com/lh3/59882d6b96166dfc3d8d> for a snapshot.

-__host__ __device__ uint64_t hash_64(uint64_t key, uint64_t mask)
+__host__ __device__ uint64_t ahash_64(uint64_t key, uint64_t mask)
 {
 	key = (~key + (key << 21)) & mask; // key = (key << 21) - key - 1;
 	key = key ^ key >> 24;
@@ -143,7 +143,7 @@ __host__ __device__ uint64_t hash_64(uint64_t key, uint64_t mask)

 // The inversion of hash_64(). Modified from
 // <https://naml.us/blog/tag/invertible>
-__host__ __device__ uint64_t hash_64i(uint64_t key, uint64_t mask)
+__host__ __device__ uint64_t ahash_64i(uint64_t key, uint64_t mask)
 {
 	uint64_t tmp;

